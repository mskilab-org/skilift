#' @description
#' Creates a multiplicity data table from SNV copy number data, handling both somatic and germline cases.
#'
#' @param snv_cn Path to SNV copy number RDS file or data.table object
#' @param is_germline Logical indicating if mutations are germline (default: FALSE)
#' @param field Column name to use for copy number values (default: "total_copies")
#'
#' @return data.table containing processed mutation data
#' @export
create_multiplicity <- function(snv_cn, is_germline = FALSE, field = "total_copies") {
  
  mutations.dt <- tryCatch({
    if (!grepl("\\.rds$", snv_cn)) {
      message("Expected .rds ending for mutations. Attempting to read anyway: ", snv_cn)
    }
    as.data.table(readRDS(snv_cn))
  }, error = function(e){
    message(paste0("Input was not .rds; failed with '", e$message, "'\nAssuming input is .maf"))
    return(fread(snv_cn) %>% dt2gr %>% gr2dt)
  }, finally = {
    message("Finished attempting to load input.")
  })

  if (is.null(mutations.dt)) {
    stop("Failed to assign a valid value to mutations.dt.")
  } else{
    message("Successfully loaded input snv_cn.")
  }

  if (!any(class(mutations.dt) == "data.table")) {
    stop("Input must be a data.table.")
  }
  
  ## Process mutations
  setnames(mutations.dt, old = "VAF", new = "vaf", skip_absent = TRUE)
  mutations.dt <- mutations.dt[!is.na(get(field)), ]
  mutations.dt[start == end, end := end + 1]
  mutations.dt[, vaf := round(vaf, 3)] ## round for frontend legibility
  mutations.dt[, ONCOGENIC := fcase(
                   is.na(ONCOGENIC), "",
                   grepl("Unknown", ONCOGENIC), "", ## necessitated by frontend implementation
                   default = ONCOGENIC
                 )]
  mutations.dt[, MUTATION_EFFECT := fcase(
                   is.na(MUTATION_EFFECT), "",
                   grepl("Unknown", MUTATION_EFFECT), "", ## extraneous string
                   default = MUTATION_EFFECT
                 )]
  mutations.dt[, HIGHEST_LEVEL := fcase(
                   HIGHEST_LEVEL == "" | is.na(HIGHEST_LEVEL), "",
                   default = gsub("LEVEL_", "", HIGHEST_LEVEL) ## extraneous string
                 )]
  
  mutations.dt <- mutations.dt[FILTER == "PASS"] #### TEMPORARY before implementation of fast coverage
  
  if ("strand" %in% colnames(mutations.dt)) {
    mutations.dt[, strand := NULL]
  }

  ## Create annotation string
  mut_ann <- ""
  annotation_fields <- list(
    Variant_Classification = "Type",
    Gene = "Gene",
    HGVSc = "Variant",
    HGVSp = "Protein_variant",
    variant.g = "Genomic_variant",
    vaf = "VAF",
    alt = "Alt_count",
    ref = "Ref_count",
    normal.alt = "Normal_alt_count",
    normal.ref = "Normal_ref_count",
    FILTER = "Filter",
    ONCOGENIC = "Oncogenicity",
    MUTATION_EFFECT = "Effect",
    HIGHEST_LEVEL = "Level"
  )
  
  for (col in names(annotation_fields)) {
    if (col %in% colnames(mutations.dt)) {
      print(col)
      mut_ann <- paste0(mut_ann, annotation_fields[[col]], ": ", mutations.dt[[col]], "; ")
    }
  }
  
  mutations.dt[, annotation := mut_ann]
  
  return(mutations.dt)
}

#' @title Convert Multiplicity Data to Intervals
#' @description
#' Converts multiplicity data into a list of intervals and settings for visualization
#'
#' @param multiplicity data.table containing mutation data with seqnames, start, and end columns
#' @param field Column name to use for y-axis values (default: "total_copies")
#' @param settings Path to settings JSON file
#' @param node_metadata Additional columns to include in node data (default: NULL)
#' @param reference_name Reference genome name (default: "hg19")
#'
#' @return List containing settings and intervals for visualization
#' @export
multiplicity_to_intervals <- function(
    multiplicity,
    field = "total_copies",
    settings = Skilift:::default_settings_path,
    node_metadata = NULL,
    reference_name = "hg19"
) {
    # Load chromosome lengths from settings
    settings_data <- jsonlite::fromJSON(settings)
    chrom_lengths <- as.data.table(
        settings_data$coordinates$sets[[reference_name]])[
        , .(chromosome, startPoint, endPoint)
    ]
    setnames(chrom_lengths, c("seqnames", "start", "end"))

    # Ensure chromosome naming consistency
    if (nrow(chrom_lengths[grepl("chr", seqnames), ]) > 0) {
        chrom_lengths[!grepl("chr", seqnames), 
                     seqnames := paste0("chr", seqnames)]
    }

    # Set y-values from specified field
    multiplicity[, y_value := get(field)]

    # Convert to GRanges
    gr = dt2gr(multiplicity[order(seqnames, start), ]) %>% sortSeqlevels()
    if (nrow(chrom_lengths[grepl("chr", seqnames), ]) > 0) {
        GenomeInfoDb::seqlevelsStyle(gr) = "UCSC"
    } else {
        GenomeInfoDb::seqlevelsStyle(gr) = "NCBI"
    }

    # Validate ranges
    if (any(gr@seqinfo@seqlengths > 
            chrom_lengths[seqnames %in% names(seqlengths(gr))]$end)) {
        stop(paste("Ranges exceed chromosome lengths in", reference_name))
    }

    # Create graph object and convert to data.table
    jab <- gG(nodes = gr)
    node_cols <- c("snode.id", "y_value", "annotation")###node_metadata)
    node_dt <- gr2dt(jab$nodes$gr[, node_cols])

    # Create final node data
    intervals <- node_dt[, .(
        chromosome = seqnames,
        startPoint = start,
        endPoint = end,
        iid = snode.id,
        title = snode.id,
        type = "interval",
        y = y_value,
        annotation = node_dt$annotation
    )]

    # Construct return list
    list(
        settings = list(
            y_axis = list(
                title = "copy number",
                visible = TRUE
            )
        ),
        intervals = intervals,
        connections = data.table()
    )
}


#' @name lift_multiplicity
#' @title lift_multiplicity
#' @description
#' Create multiplicity JSON files for all samples in a cohort
#'
#' @param cohort Cohort object containing sample information
#' @param is_germline Logical indicating if mutations are germline (default: FALSE)
#' @param output_data_dir Base directory for output files
#' @param cores Number of cores for parallel processing (default: 1)
#' @return None
#' @export
lift_multiplicity <- function(
    cohort,
    is_germline = FALSE,
    node_metadata = c("Variant_Classification","Gene", "HGVSc", "HGVSp","variant.g","vaf","alt","ref","normal.alt","normal.ref","FILTER","ONCOGENIC","MUTATION_EFFECT","HIGHEST_LEVEL"),
    output_data_dir,
    field = "altered_copies",
    cores = 1
) {
    if (!inherits(cohort, "Cohort")) {
        stop("Input must be a Cohort object")
    }
    
    if (!dir.exists(output_data_dir)) {
        dir.create(output_data_dir, recursive = TRUE)
    }
    
    # Determine which column to use based on is_germline
    snv_cn_col <- if(is_germline) "germline_multiplicity" else "multiplicity"
    
    # Validate required column exists
    if (!snv_cn_col %in% names(cohort$inputs)) {
        stop(sprintf("Missing required column in cohort: %s", snv_cn_col))
    }
    
    # Get reference name from cohort
    reference_name <- cohort$reference_name
    if (is.null(reference_name)) {
        stop("Reference name not found in cohort object")
    }

    #browser()
    
    # Process each sample in parallel
    mclapply(seq_len(nrow(cohort$inputs)), function(i) {
        row <- cohort$inputs[i,]
        pair_dir <- file.path(output_data_dir, row$pair)
        
        if (!dir.exists(pair_dir)) {
            dir.create(pair_dir, recursive = TRUE)
        }
        
        # Determine output filename based on is_germline
        out_file <- file.path(
            pair_dir,
            if(is_germline) "germline_mutations.json" else "mutations.json"
        ) %>% normalizePath

        tryCatch({
           # Create multiplicity data.table
                     
            mult_dt <- create_multiplicity(
                snv_cn = row[[snv_cn_col]],
                is_germline = is_germline,
                field = row$multiplicity_field
            )

            # Convert to intervals
            intervals_list <- multiplicity_to_intervals(
                multiplicity = mult_dt,
                reference_name = cohort$reference_name,
                node_metadata = unlist(row$multiplicity_node_metadata),
                field = row$multiplicity_field
            )

            # Write to JSON
            jsonlite::write_json(
                intervals_list,
                out_file,
                pretty = TRUE,
                auto_unbox = TRUE,
                digits = 4
            )

            message(sprintf("Successfully processed %s, saved at %s", row$pair, out_file))
            
        }, error = function(e) {
            warning(sprintf("Error processing %s: %s", row$pair, e$message))
        })
    }, mc.cores = cores, mc.preschedule = FALSE)
    
    invisible(NULL)
}
